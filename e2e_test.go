package main

import (
	"bytes"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"gogen/internal/config"
	"gogen/internal/generator"
	"gogen/internal/parser"
)

// TestE2E_TypeScriptGeneration tests the complete pipeline for TypeScript generation.
func TestE2E_TypeScriptGeneration(t *testing.T) {
	// Create test input
	inputContent := `package models

import (
	"time"
	"github.com/google/uuid"
)

// User represents a user in the system.
type User struct {
	ID        uuid.UUID  ` + "`json:\"id\"`" + `
	Email     string     ` + "`json:\"email\"`" + `
	Name      string     ` + "`json:\"name\"`" + `
	Age       int        ` + "`json:\"age,omitempty\"`" + `
	CreatedAt time.Time  ` + "`json:\"createdAt\"`" + `
	UpdatedAt *time.Time ` + "`json:\"updatedAt,omitempty\"`" + `
	Tags      []string   ` + "`json:\"tags\"`" + `
}

// Role is a named string type.
type Role string

// Status is an alias for int.
type Status = int
`

	// Create temp directory
	tmpDir := t.TempDir()
	inputPath := filepath.Join(tmpDir, "input.go")
	templatePath := filepath.Join(tmpDir, "typescript.tmpl")

	// Write input file
	if err := os.WriteFile(inputPath, []byte(inputContent), 0644); err != nil {
		t.Fatalf("failed to write input file: %v", err)
	}

	// Write template file
	templateContent := `{{- /* TypeScript type definitions */ -}}
// Code generated by gogen. DO NOT EDIT.

{{ range .Types -}}
{{ if eq .Kind "struct" -}}
export interface {{ .Name }} {
{{- range .Fields }}
  {{ tagOrName . }}{{ if isOptional . }}?{{ end }}: {{ mapType .Type }};
{{- end }}
}
{{ else if or (eq .Kind "alias") (eq .Kind "named") -}}
export type {{ .Name }} = {{ mapType .Underlying }};
{{ end }}
{{ end -}}
`
	if err := os.WriteFile(templatePath, []byte(templateContent), 0644); err != nil {
		t.Fatalf("failed to write template file: %v", err)
	}

	// Run the pipeline
	cfg := config.New()
	p := parser.New()

	file, err := p.ParseFile(inputPath)
	if err != nil {
		t.Fatalf("failed to parse file: %v", err)
	}

	gen := generator.New(cfg)
	if err := gen.LoadTemplate(templatePath); err != nil {
		t.Fatalf("failed to load template: %v", err)
	}

	var buf bytes.Buffer
	if err := gen.Generate(file, &buf); err != nil {
		t.Fatalf("failed to generate: %v", err)
	}

	output := buf.String()

	// Verify output contains expected elements
	tests := []struct {
		name     string
		contains string
	}{
		{"interface User", "export interface User {"},
		{"id field", "id: string;"},
		{"email field", "email: string;"},
		{"age optional", "age?: number;"},
		{"createdAt datetime", "createdAt: string;"},
		{"updatedAt nullable optional", "updatedAt?: string | null;"},
		{"tags array", "tags: string[];"},
		{"Role type", "export type Role = string;"},
		{"Status alias", "export type Status = number;"},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			if !strings.Contains(output, tc.contains) {
				t.Errorf("output does not contain %q\nGot:\n%s", tc.contains, output)
			}
		})
	}
}

// TestE2E_ZodGeneration tests Zod schema generation.
func TestE2E_ZodGeneration(t *testing.T) {
	inputContent := `package models

type Product struct {
	ID    string  ` + "`json:\"id\"`" + `
	Name  string  ` + "`json:\"name\"`" + `
	Price float64 ` + "`json:\"price\"`" + `
	Tags  []string ` + "`json:\"tags\"`" + `
	Meta  map[string]any ` + "`json:\"meta,omitempty\"`" + `
}
`
	tmpDir := t.TempDir()
	inputPath := filepath.Join(tmpDir, "input.go")
	templatePath := filepath.Join(tmpDir, "zod.tmpl")

	if err := os.WriteFile(inputPath, []byte(inputContent), 0644); err != nil {
		t.Fatalf("failed to write input file: %v", err)
	}

	templateContent := `{{- /* Zod validation schemas */ -}}
import { z } from 'zod';
{{ range .Types }}
{{- if eq .Kind "struct" }}
export const {{ .Name }}Schema = z.object({
{{- range $i, $f := .Fields }}
  {{ tagOrName $f }}: {{ template "zodType" $f.Type }}{{ if isOptional $f }}.optional(){{ end }},
{{- end }}
});

export type {{ .Name }} = z.infer<typeof {{ .Name }}Schema>;
{{ end -}}
{{ end }}
{{- define "zodType" -}}
{{- if eq .Kind "basic" -}}
{{- if eq .Name "string" -}}z.string()
{{- else if eq .Name "bool" -}}z.boolean()
{{- else if or (hasPrefix .Name "int") (hasPrefix .Name "uint") (hasPrefix .Name "float") (eq .Name "byte") (eq .Name "rune") -}}z.number()
{{- else if eq .Name "any" -}}z.unknown()
{{- else -}}z.unknown()
{{- end -}}
{{- else if eq .Kind "slice" -}}z.array({{ template "zodType" .Elem }})
{{- else if eq .Kind "array" -}}z.array({{ template "zodType" .Elem }})
{{- else if eq .Kind "map" -}}z.record({{ template "zodType" .Key }}, {{ template "zodType" .Value }})
{{- else if eq .Kind "pointer" -}}{{ template "zodType" .Elem }}.nullable()
{{- else -}}z.unknown()
{{- end -}}
{{- end -}}
`
	if err := os.WriteFile(templatePath, []byte(templateContent), 0644); err != nil {
		t.Fatalf("failed to write template file: %v", err)
	}

	cfg := config.New()
	p := parser.New()

	file, err := p.ParseFile(inputPath)
	if err != nil {
		t.Fatalf("failed to parse file: %v", err)
	}

	gen := generator.New(cfg)
	if err := gen.LoadTemplate(templatePath); err != nil {
		t.Fatalf("failed to load template: %v", err)
	}

	var buf bytes.Buffer
	if err := gen.Generate(file, &buf); err != nil {
		t.Fatalf("failed to generate: %v", err)
	}

	output := buf.String()

	tests := []struct {
		name     string
		contains string
	}{
		{"zod import", "import { z } from 'zod';"},
		{"ProductSchema", "export const ProductSchema = z.object({"},
		{"id z.string", "id: z.string()"},
		{"price z.number", "price: z.number()"},
		{"tags z.array", "tags: z.array(z.string())"},
		{"meta z.record optional", "meta: z.record(z.string(), z.unknown()).optional()"},
		{"type inference", "export type Product = z.infer<typeof ProductSchema>;"},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			if !strings.Contains(output, tc.contains) {
				t.Errorf("output does not contain %q\nGot:\n%s", tc.contains, output)
			}
		})
	}
}

// TestE2E_ValibotGeneration tests Valibot schema generation.
func TestE2E_ValibotGeneration(t *testing.T) {
	inputContent := `package models

type Product struct {
	ID    string  ` + "`json:\"id\"`" + `
	Name  string  ` + "`json:\"name\"`" + `
	Price float64 ` + "`json:\"price\"`" + `
	Tags  []string ` + "`json:\"tags\"`" + `
	Meta  map[string]any ` + "`json:\"meta,omitempty\"`" + `
	Alias *string ` + "`json:\"alias,omitempty\"`" + `
}
`
	tmpDir := t.TempDir()
	inputPath := filepath.Join(tmpDir, "input.go")
	templatePath := filepath.Join(tmpDir, "valibot.tmpl")

	if err := os.WriteFile(inputPath, []byte(inputContent), 0644); err != nil {
		t.Fatalf("failed to write input file: %v", err)
	}

	templateContent := `{{- /* Valibot validation schemas */ -}}
import * as v from 'valibot';
{{ range .Types }}
{{- if eq .Kind "struct" }}
export const {{ .Name }}Schema = v.object({
{{- range $i, $f := .Fields }}
  {{ tagOrName $f }}: {{ template "valibotType" $f.Type }}{{ if isOptional $f }}.optional(){{ end }},
{{- end }}
});

export type {{ .Name }} = v.InferOutput<typeof {{ .Name }}Schema>;
{{ end -}}
{{ end }}
{{- define "valibotType" -}}
{{- if eq .Kind "basic" -}}
{{- if eq .Name "string" -}}v.string()
{{- else if eq .Name "bool" -}}v.boolean()
{{- else if or (hasPrefix .Name "int") (hasPrefix .Name "uint") (hasPrefix .Name "float") (eq .Name "byte") (eq .Name "rune") -}}v.number()
{{- else if eq .Name "any" -}}v.unknown()
{{- else -}}v.unknown()
{{- end -}}
{{- else if eq .Kind "slice" -}}v.array({{ template "valibotType" .Elem }})
{{- else if eq .Kind "array" -}}v.array({{ template "valibotType" .Elem }})
{{- else if eq .Kind "map" -}}v.record({{ template "valibotType" .Key }}, {{ template "valibotType" .Value }})
{{- else if eq .Kind "pointer" -}}v.nullable({{ template "valibotType" .Elem }})
{{- else -}}v.unknown()
{{- end -}}
{{- end -}}
`
	if err := os.WriteFile(templatePath, []byte(templateContent), 0644); err != nil {
		t.Fatalf("failed to write template file: %v", err)
	}

	cfg := config.New()
	p := parser.New()

	file, err := p.ParseFile(inputPath)
	if err != nil {
		t.Fatalf("failed to parse file: %v", err)
	}

	gen := generator.New(cfg)
	if err := gen.LoadTemplate(templatePath); err != nil {
		t.Fatalf("failed to load template: %v", err)
	}

	var buf bytes.Buffer
	if err := gen.Generate(file, &buf); err != nil {
		t.Fatalf("failed to generate: %v", err)
	}

	output := buf.String()

	tests := []struct {
		name     string
		contains string
	}{
		{"valibot import", "import * as v from 'valibot';"},
		{"ProductSchema", "export const ProductSchema = v.object({"},
		{"id v.string", "id: v.string()"},
		{"price v.number", "price: v.number()"},
		{"tags v.array", "tags: v.array(v.string())"},
		{"meta v.record optional", "meta: v.record(v.string(), v.unknown()).optional()"},
		{"alias v.nullable optional", "alias: v.nullable(v.string()).optional()"},
		{"type inference", "export type Product = v.InferOutput<typeof ProductSchema>;"},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			if !strings.Contains(output, tc.contains) {
				t.Errorf("output does not contain %q\nGot:\n%s", tc.contains, output)
			}
		})
	}
}

// TestE2E_ValibotFormGeneration tests Valibot form schema generation with validate tags.
func TestE2E_ValibotFormGeneration(t *testing.T) {
	inputContent := `package models

type UnitMessage struct {
	Code        string  ` + "`json:\"code\" validate:\"required,min=1,max=45\"`" + `
	Name        string  ` + "`json:\"name\" validate:\"required,min=2,max=45\"`" + `
	Description string  ` + "`json:\"description\" validate:\"max=255\"`" + `
	Email       string  ` + "`json:\"email\" validate:\"email\"`" + `
	Website     string  ` + "`json:\"website\" validate:\"url\"`" + `
	Count       int     ` + "`json:\"count\" validate:\"min=0,max=100\"`" + `
	Price       float64 ` + "`json:\"price\"`" + `
	Active      bool    ` + "`json:\"active\"`" + `
	Tags        []string ` + "`json:\"tags\"`" + `
	Meta        map[string]string ` + "`json:\"meta\"`" + `
}
`
	tmpDir := t.TempDir()
	inputPath := filepath.Join(tmpDir, "input.go")

	if err := os.WriteFile(inputPath, []byte(inputContent), 0644); err != nil {
		t.Fatalf("failed to write input file: %v", err)
	}

	// Use the actual valibot-form.tmpl template
	templatePath := "templates/valibot-form.tmpl"
	if _, err := os.Stat(templatePath); os.IsNotExist(err) {
		t.Skip("valibot-form.tmpl not found")
	}

	cfg := config.New()
	p := parser.New()

	file, err := p.ParseFile(inputPath)
	if err != nil {
		t.Fatalf("failed to parse file: %v", err)
	}

	gen := generator.New(cfg)
	if err := gen.LoadTemplate(templatePath); err != nil {
		t.Fatalf("failed to load template: %v", err)
	}

	var buf bytes.Buffer
	if err := gen.Generate(file, &buf); err != nil {
		t.Fatalf("failed to generate: %v", err)
	}

	output := buf.String()

	tests := []struct {
		name     string
		contains string
	}{
		{"valibot import", "import * as v from 'valibot';"},
		{"schema definition", "export const UnitMessageSchema = v.object({"},
		{"code with minLength/maxLength", "v.pipe(v.optional(v.string(), ''), v.minLength(1), v.maxLength(45))"},
		{"name with minLength/maxLength", "v.pipe(v.optional(v.string(), ''), v.minLength(2), v.maxLength(45))"},
		{"description with maxLength only", "v.pipe(v.optional(v.string(), ''), v.maxLength(255))"},
		{"email validation", "v.pipe(v.optional(v.string(), ''), v.email())"},
		{"url validation", "v.pipe(v.optional(v.string(), ''), v.url())"},
		{"count with minValue/maxValue", "v.pipe(v.optional(v.number(), 0), v.minValue(0), v.maxValue(100))"},
		{"price number default", "v.optional(v.number(), 0)"},
		{"active boolean default", "v.optional(v.boolean(), false)"},
		{"tags array default", "v.optional(v.array(v.string()), [])"},
		{"meta record default", "v.optional(v.record(v.string(), v.string()), {})"},
		{"type inference", "export type UnitMessage = v.InferOutput<typeof UnitMessageSchema>;"},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			if !strings.Contains(output, tc.contains) {
				t.Errorf("output does not contain %q\nGot:\n%s", tc.contains, output)
			}
		})
	}
}

// TestE2E_EmbeddedFields tests that embedded fields are flattened.
func TestE2E_EmbeddedFields(t *testing.T) {
	inputContent := `package models

type Timestamps struct {
	CreatedAt string ` + "`json:\"createdAt\"`" + `
	UpdatedAt string ` + "`json:\"updatedAt\"`" + `
}

type Entity struct {
	ID string ` + "`json:\"id\"`" + `
	Timestamps
}
`
	tmpDir := t.TempDir()
	inputPath := filepath.Join(tmpDir, "input.go")
	templatePath := filepath.Join(tmpDir, "ts.tmpl")

	if err := os.WriteFile(inputPath, []byte(inputContent), 0644); err != nil {
		t.Fatalf("failed to write input file: %v", err)
	}

	templateContent := `{{ range .Types -}}
{{ if eq .Kind "struct" -}}
interface {{ .Name }} {
{{- range .Fields }}
  {{ tagOrName . }}: {{ mapType .Type }};
{{- end }}
}
{{ end }}
{{ end -}}
`
	if err := os.WriteFile(templatePath, []byte(templateContent), 0644); err != nil {
		t.Fatalf("failed to write template file: %v", err)
	}

	cfg := config.New()
	p := parser.New()

	file, err := p.ParseFile(inputPath)
	if err != nil {
		t.Fatalf("failed to parse file: %v", err)
	}

	gen := generator.New(cfg)
	if err := gen.LoadTemplate(templatePath); err != nil {
		t.Fatalf("failed to load template: %v", err)
	}

	var buf bytes.Buffer
	if err := gen.Generate(file, &buf); err != nil {
		t.Fatalf("failed to generate: %v", err)
	}

	output := buf.String()

	// Entity should have flattened fields from Timestamps
	if !strings.Contains(output, "interface Entity {") {
		t.Errorf("output does not contain Entity interface\nGot:\n%s", output)
	}

	// Check Entity has embedded fields
	entityIdx := strings.Index(output, "interface Entity {")
	if entityIdx == -1 {
		t.Fatal("Entity interface not found")
	}

	entitySection := output[entityIdx:]
	endIdx := strings.Index(entitySection, "}")
	if endIdx == -1 {
		t.Fatal("Entity interface end not found")
	}
	entitySection = entitySection[:endIdx+1]

	if !strings.Contains(entitySection, "id:") {
		t.Errorf("Entity should have id field\nGot:\n%s", entitySection)
	}
	if !strings.Contains(entitySection, "createdAt:") {
		t.Errorf("Entity should have createdAt field (flattened from Timestamps)\nGot:\n%s", entitySection)
	}
	if !strings.Contains(entitySection, "updatedAt:") {
		t.Errorf("Entity should have updatedAt field (flattened from Timestamps)\nGot:\n%s", entitySection)
	}
}

// TestE2E_ConfigTypeFiltering tests include/exclude type filtering.
func TestE2E_ConfigTypeFiltering(t *testing.T) {
	inputContent := `package models

type User struct {
	ID string ` + "`json:\"id\"`" + `
}

type Admin struct {
	ID string ` + "`json:\"id\"`" + `
}

type Guest struct {
	ID string ` + "`json:\"id\"`" + `
}
`
	tmpDir := t.TempDir()
	inputPath := filepath.Join(tmpDir, "input.go")
	templatePath := filepath.Join(tmpDir, "ts.tmpl")

	if err := os.WriteFile(inputPath, []byte(inputContent), 0644); err != nil {
		t.Fatalf("failed to write input file: %v", err)
	}

	templateContent := `{{ range .Types -}}
type {{ .Name }}
{{ end -}}
`
	if err := os.WriteFile(templatePath, []byte(templateContent), 0644); err != nil {
		t.Fatalf("failed to write template file: %v", err)
	}

	t.Run("include only User", func(t *testing.T) {
		cfg := config.New()
		cfg.Options.IncludeTypes = []string{"User"}

		p := parser.New()
		file, err := p.ParseFile(inputPath)
		if err != nil {
			t.Fatalf("failed to parse file: %v", err)
		}

		gen := generator.New(cfg)
		if err := gen.LoadTemplate(templatePath); err != nil {
			t.Fatalf("failed to load template: %v", err)
		}

		var buf bytes.Buffer
		if err := gen.Generate(file, &buf); err != nil {
			t.Fatalf("failed to generate: %v", err)
		}

		output := buf.String()

		if !strings.Contains(output, "type User") {
			t.Errorf("output should contain User\nGot:\n%s", output)
		}
		if strings.Contains(output, "type Admin") {
			t.Errorf("output should NOT contain Admin\nGot:\n%s", output)
		}
		if strings.Contains(output, "type Guest") {
			t.Errorf("output should NOT contain Guest\nGot:\n%s", output)
		}
	})

	t.Run("exclude Guest", func(t *testing.T) {
		cfg := config.New()
		cfg.Options.ExcludeTypes = []string{"Guest"}

		p := parser.New()
		file, err := p.ParseFile(inputPath)
		if err != nil {
			t.Fatalf("failed to parse file: %v", err)
		}

		gen := generator.New(cfg)
		if err := gen.LoadTemplate(templatePath); err != nil {
			t.Fatalf("failed to load template: %v", err)
		}

		var buf bytes.Buffer
		if err := gen.Generate(file, &buf); err != nil {
			t.Fatalf("failed to generate: %v", err)
		}

		output := buf.String()

		if !strings.Contains(output, "type User") {
			t.Errorf("output should contain User\nGot:\n%s", output)
		}
		if !strings.Contains(output, "type Admin") {
			t.Errorf("output should contain Admin\nGot:\n%s", output)
		}
		if strings.Contains(output, "type Guest") {
			t.Errorf("output should NOT contain Guest\nGot:\n%s", output)
		}
	})
}

// TestE2E_ExportedOnlyFiltering tests that unexported types are filtered.
func TestE2E_ExportedOnlyFiltering(t *testing.T) {
	inputContent := `package models

type PublicUser struct {
	ID string ` + "`json:\"id\"`" + `
}

type privateUser struct {
	ID string ` + "`json:\"id\"`" + `
}
`
	tmpDir := t.TempDir()
	inputPath := filepath.Join(tmpDir, "input.go")
	templatePath := filepath.Join(tmpDir, "ts.tmpl")

	if err := os.WriteFile(inputPath, []byte(inputContent), 0644); err != nil {
		t.Fatalf("failed to write input file: %v", err)
	}

	templateContent := `{{ range .Types -}}
type {{ .Name }}
{{ end -}}
`
	if err := os.WriteFile(templatePath, []byte(templateContent), 0644); err != nil {
		t.Fatalf("failed to write template file: %v", err)
	}

	t.Run("exported only (default)", func(t *testing.T) {
		cfg := config.New()
		// Default is ExportedOnly = true

		p := parser.New()
		file, err := p.ParseFile(inputPath)
		if err != nil {
			t.Fatalf("failed to parse file: %v", err)
		}

		gen := generator.New(cfg)
		if err := gen.LoadTemplate(templatePath); err != nil {
			t.Fatalf("failed to load template: %v", err)
		}

		var buf bytes.Buffer
		if err := gen.Generate(file, &buf); err != nil {
			t.Fatalf("failed to generate: %v", err)
		}

		output := buf.String()

		if !strings.Contains(output, "type PublicUser") {
			t.Errorf("output should contain PublicUser\nGot:\n%s", output)
		}
		if strings.Contains(output, "type privateUser") {
			t.Errorf("output should NOT contain privateUser\nGot:\n%s", output)
		}
	})

	t.Run("include unexported", func(t *testing.T) {
		cfg := config.New()
		cfg.Options.ExportedOnly = false

		p := parser.New()
		file, err := p.ParseFile(inputPath)
		if err != nil {
			t.Fatalf("failed to parse file: %v", err)
		}

		gen := generator.New(cfg)
		if err := gen.LoadTemplate(templatePath); err != nil {
			t.Fatalf("failed to load template: %v", err)
		}

		var buf bytes.Buffer
		if err := gen.Generate(file, &buf); err != nil {
			t.Fatalf("failed to generate: %v", err)
		}

		output := buf.String()

		if !strings.Contains(output, "type PublicUser") {
			t.Errorf("output should contain PublicUser\nGot:\n%s", output)
		}
		if !strings.Contains(output, "type privateUser") {
			t.Errorf("output should contain privateUser when ExportedOnly=false\nGot:\n%s", output)
		}
	})
}

// TestE2E_MapTypes tests map type generation.
func TestE2E_MapTypes(t *testing.T) {
	inputContent := `package models

type Config struct {
	Settings map[string]string ` + "`json:\"settings\"`" + `
	Counts   map[string]int    ` + "`json:\"counts\"`" + `
	Nested   map[string]map[string]bool ` + "`json:\"nested\"`" + `
}
`
	tmpDir := t.TempDir()
	inputPath := filepath.Join(tmpDir, "input.go")
	templatePath := filepath.Join(tmpDir, "ts.tmpl")

	if err := os.WriteFile(inputPath, []byte(inputContent), 0644); err != nil {
		t.Fatalf("failed to write input file: %v", err)
	}

	templateContent := `{{ range .Types -}}
{{ if eq .Kind "struct" -}}
interface {{ .Name }} {
{{- range .Fields }}
  {{ tagOrName . }}: {{ mapType .Type }};
{{- end }}
}
{{ end }}
{{ end -}}
`
	if err := os.WriteFile(templatePath, []byte(templateContent), 0644); err != nil {
		t.Fatalf("failed to write template file: %v", err)
	}

	cfg := config.New()
	p := parser.New()

	file, err := p.ParseFile(inputPath)
	if err != nil {
		t.Fatalf("failed to parse file: %v", err)
	}

	gen := generator.New(cfg)
	if err := gen.LoadTemplate(templatePath); err != nil {
		t.Fatalf("failed to load template: %v", err)
	}

	var buf bytes.Buffer
	if err := gen.Generate(file, &buf); err != nil {
		t.Fatalf("failed to generate: %v", err)
	}

	output := buf.String()

	tests := []struct {
		name     string
		contains string
	}{
		{"string to string map", "settings: Record<string, string>;"},
		{"string to number map", "counts: Record<string, number>;"},
		{"nested map", "nested: Record<string, Record<string, boolean>>;"},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			if !strings.Contains(output, tc.contains) {
				t.Errorf("output does not contain %q\nGot:\n%s", tc.contains, output)
			}
		})
	}
}

// TestE2E_PointerTypes tests pointer type generation with nullable.
func TestE2E_PointerTypes(t *testing.T) {
	inputContent := `package models

type Entity struct {
	Name    string  ` + "`json:\"name\"`" + `
	Alias   *string ` + "`json:\"alias\"`" + `
	Parent  *Entity ` + "`json:\"parent\"`" + `
}
`
	tmpDir := t.TempDir()
	inputPath := filepath.Join(tmpDir, "input.go")
	templatePath := filepath.Join(tmpDir, "ts.tmpl")

	if err := os.WriteFile(inputPath, []byte(inputContent), 0644); err != nil {
		t.Fatalf("failed to write input file: %v", err)
	}

	templateContent := `{{ range .Types -}}
{{ if eq .Kind "struct" -}}
interface {{ .Name }} {
{{- range .Fields }}
  {{ tagOrName . }}{{ if isOptional . }}?{{ end }}: {{ mapType .Type }};
{{- end }}
}
{{ end }}
{{ end -}}
`
	if err := os.WriteFile(templatePath, []byte(templateContent), 0644); err != nil {
		t.Fatalf("failed to write template file: %v", err)
	}

	cfg := config.New()
	p := parser.New()

	file, err := p.ParseFile(inputPath)
	if err != nil {
		t.Fatalf("failed to parse file: %v", err)
	}

	gen := generator.New(cfg)
	if err := gen.LoadTemplate(templatePath); err != nil {
		t.Fatalf("failed to load template: %v", err)
	}

	var buf bytes.Buffer
	if err := gen.Generate(file, &buf); err != nil {
		t.Fatalf("failed to generate: %v", err)
	}

	output := buf.String()

	tests := []struct {
		name     string
		contains string
	}{
		{"non-pointer string", "name: string;"},
		{"pointer string nullable optional", "alias?: string | null;"},
		{"pointer to self nullable optional", "parent?: Entity | null;"},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			if !strings.Contains(output, tc.contains) {
				t.Errorf("output does not contain %q\nGot:\n%s", tc.contains, output)
			}
		})
	}
}

// TestE2E_SliceTypes tests slice and array type generation.
func TestE2E_SliceTypes(t *testing.T) {
	inputContent := `package models

type Collection struct {
	Names    []string    ` + "`json:\"names\"`" + `
	Numbers  []int       ` + "`json:\"numbers\"`" + `
	Items    []Item      ` + "`json:\"items\"`" + `
	Matrix   [][]string  ` + "`json:\"matrix\"`" + `
}

type Item struct {
	ID string ` + "`json:\"id\"`" + `
}
`
	tmpDir := t.TempDir()
	inputPath := filepath.Join(tmpDir, "input.go")
	templatePath := filepath.Join(tmpDir, "ts.tmpl")

	if err := os.WriteFile(inputPath, []byte(inputContent), 0644); err != nil {
		t.Fatalf("failed to write input file: %v", err)
	}

	templateContent := `{{ range .Types -}}
{{ if eq .Kind "struct" -}}
interface {{ .Name }} {
{{- range .Fields }}
  {{ tagOrName . }}: {{ mapType .Type }};
{{- end }}
}
{{ end }}
{{ end -}}
`
	if err := os.WriteFile(templatePath, []byte(templateContent), 0644); err != nil {
		t.Fatalf("failed to write template file: %v", err)
	}

	cfg := config.New()
	p := parser.New()

	file, err := p.ParseFile(inputPath)
	if err != nil {
		t.Fatalf("failed to parse file: %v", err)
	}

	gen := generator.New(cfg)
	if err := gen.LoadTemplate(templatePath); err != nil {
		t.Fatalf("failed to load template: %v", err)
	}

	var buf bytes.Buffer
	if err := gen.Generate(file, &buf); err != nil {
		t.Fatalf("failed to generate: %v", err)
	}

	output := buf.String()

	tests := []struct {
		name     string
		contains string
	}{
		{"string slice", "names: string[];"},
		{"number slice", "numbers: number[];"},
		{"custom type slice", "items: Item[];"},
		{"nested slice", "matrix: string[][];"},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			if !strings.Contains(output, tc.contains) {
				t.Errorf("output does not contain %q\nGot:\n%s", tc.contains, output)
			}
		})
	}
}

// TestE2E_ConfigFromYAML tests loading configuration from YAML.
func TestE2E_ConfigFromYAML(t *testing.T) {
	configContent := `typeMappings:
  "time.Time": "Date"
  "uuid.UUID": "UUID"
options:
  tagKey: "json"
  exportedOnly: true
  excludeTypes:
    - "Internal"
`
	tmpDir := t.TempDir()
	configPath := filepath.Join(tmpDir, "config.yaml")

	if err := os.WriteFile(configPath, []byte(configContent), 0644); err != nil {
		t.Fatalf("failed to write config file: %v", err)
	}

	cfg := config.New()
	if err := cfg.LoadFile(configPath); err != nil {
		t.Fatalf("failed to load config: %v", err)
	}

	// Verify custom type mappings were applied
	if cfg.TypeMappings["time.Time"] != "Date" {
		t.Errorf("expected time.Time -> Date, got %s", cfg.TypeMappings["time.Time"])
	}
	if cfg.TypeMappings["uuid.UUID"] != "UUID" {
		t.Errorf("expected uuid.UUID -> UUID, got %s", cfg.TypeMappings["uuid.UUID"])
	}

	// Verify default mappings are preserved
	if cfg.TypeMappings["string"] != "string" {
		t.Errorf("expected default string mapping preserved, got %s", cfg.TypeMappings["string"])
	}

	// Verify exclude types
	if len(cfg.Options.ExcludeTypes) != 1 || cfg.Options.ExcludeTypes[0] != "Internal" {
		t.Errorf("expected excludeTypes=[Internal], got %v", cfg.Options.ExcludeTypes)
	}
}

// TestE2E_PerTypeMode tests per-type template execution.
func TestE2E_PerTypeMode(t *testing.T) {
	inputContent := `package models

type User struct {
	ID string ` + "`json:\"id\"`" + `
}

type Product struct {
	ID string ` + "`json:\"id\"`" + `
}
`
	tmpDir := t.TempDir()
	inputPath := filepath.Join(tmpDir, "input.go")
	templatePath := filepath.Join(tmpDir, "ts.tmpl")

	if err := os.WriteFile(inputPath, []byte(inputContent), 0644); err != nil {
		t.Fatalf("failed to write input file: %v", err)
	}

	// Template that outputs separator between types
	templateContent := `--- {{ .Type.Name }} ---
interface {{ .Type.Name }} {
{{- range .Type.Fields }}
  {{ tagOrName . }}: {{ mapType .Type }};
{{- end }}
}
`
	if err := os.WriteFile(templatePath, []byte(templateContent), 0644); err != nil {
		t.Fatalf("failed to write template file: %v", err)
	}

	cfg := config.New()
	cfg.Options.PerType = true

	p := parser.New()
	file, err := p.ParseFile(inputPath)
	if err != nil {
		t.Fatalf("failed to parse file: %v", err)
	}

	gen := generator.New(cfg)
	if err := gen.LoadTemplate(templatePath); err != nil {
		t.Fatalf("failed to load template: %v", err)
	}

	var buf bytes.Buffer
	if err := gen.Generate(file, &buf); err != nil {
		t.Fatalf("failed to generate: %v", err)
	}

	output := buf.String()

	// Should have separate sections for each type
	if !strings.Contains(output, "--- User ---") {
		t.Errorf("output should contain User section\nGot:\n%s", output)
	}
	if !strings.Contains(output, "--- Product ---") {
		t.Errorf("output should contain Product section\nGot:\n%s", output)
	}
}

// TestE2E_CustomTagKey tests using a custom tag key.
func TestE2E_CustomTagKey(t *testing.T) {
	inputContent := `package models

type User struct {
	ID   string ` + "`json:\"id\" yaml:\"user_id\"`" + `
	Name string ` + "`json:\"name\" yaml:\"user_name\"`" + `
}
`
	tmpDir := t.TempDir()
	inputPath := filepath.Join(tmpDir, "input.go")
	templatePath := filepath.Join(tmpDir, "ts.tmpl")

	if err := os.WriteFile(inputPath, []byte(inputContent), 0644); err != nil {
		t.Fatalf("failed to write input file: %v", err)
	}

	templateContent := `{{ range .Types -}}
{{ if eq .Kind "struct" -}}
interface {{ .Name }} {
{{- range .Fields }}
  {{ tagOrName . }}: {{ mapType .Type }};
{{- end }}
}
{{ end }}
{{ end -}}
`
	if err := os.WriteFile(templatePath, []byte(templateContent), 0644); err != nil {
		t.Fatalf("failed to write template file: %v", err)
	}

	t.Run("json tag (default)", func(t *testing.T) {
		cfg := config.New()
		// Default tagKey is "json"

		p := parser.New()
		file, err := p.ParseFile(inputPath)
		if err != nil {
			t.Fatalf("failed to parse file: %v", err)
		}

		gen := generator.New(cfg)
		if err := gen.LoadTemplate(templatePath); err != nil {
			t.Fatalf("failed to load template: %v", err)
		}

		var buf bytes.Buffer
		if err := gen.Generate(file, &buf); err != nil {
			t.Fatalf("failed to generate: %v", err)
		}

		output := buf.String()

		if !strings.Contains(output, "id:") {
			t.Errorf("output should use json tag 'id'\nGot:\n%s", output)
		}
		if !strings.Contains(output, "name:") {
			t.Errorf("output should use json tag 'name'\nGot:\n%s", output)
		}
	})

	t.Run("yaml tag", func(t *testing.T) {
		cfg := config.New()
		cfg.Options.TagKey = "yaml"

		p := parser.New()
		file, err := p.ParseFile(inputPath)
		if err != nil {
			t.Fatalf("failed to parse file: %v", err)
		}

		gen := generator.New(cfg)
		if err := gen.LoadTemplate(templatePath); err != nil {
			t.Fatalf("failed to load template: %v", err)
		}

		var buf bytes.Buffer
		if err := gen.Generate(file, &buf); err != nil {
			t.Fatalf("failed to generate: %v", err)
		}

		output := buf.String()

		if !strings.Contains(output, "user_id:") {
			t.Errorf("output should use yaml tag 'user_id'\nGot:\n%s", output)
		}
		if !strings.Contains(output, "user_name:") {
			t.Errorf("output should use yaml tag 'user_name'\nGot:\n%s", output)
		}
	})
}

// TestE2E_DocumentationComments tests that documentation is preserved.
func TestE2E_DocumentationComments(t *testing.T) {
	inputContent := `package models

// User represents a user in the system.
// It contains all user-related information.
type User struct {
	// ID is the unique identifier
	ID string ` + "`json:\"id\"`" + `
	// Name is the user's display name
	Name string ` + "`json:\"name\"`" + `
}
`
	tmpDir := t.TempDir()
	inputPath := filepath.Join(tmpDir, "input.go")
	templatePath := filepath.Join(tmpDir, "ts.tmpl")

	if err := os.WriteFile(inputPath, []byte(inputContent), 0644); err != nil {
		t.Fatalf("failed to write input file: %v", err)
	}

	templateContent := `{{ range .Types -}}
{{ if .Doc }}{{ docComment .Doc }}
{{ end -}}
{{ if eq .Kind "struct" -}}
interface {{ .Name }} {
{{- range .Fields }}
{{ if .Doc }}  /** {{ .Doc | trim }} */
{{ end -}}
  {{ tagOrName . }}: {{ mapType .Type }};
{{- end }}
}
{{ end }}
{{ end -}}
`
	if err := os.WriteFile(templatePath, []byte(templateContent), 0644); err != nil {
		t.Fatalf("failed to write template file: %v", err)
	}

	cfg := config.New()
	p := parser.New()

	file, err := p.ParseFile(inputPath)
	if err != nil {
		t.Fatalf("failed to parse file: %v", err)
	}

	gen := generator.New(cfg)
	if err := gen.LoadTemplate(templatePath); err != nil {
		t.Fatalf("failed to load template: %v", err)
	}

	var buf bytes.Buffer
	if err := gen.Generate(file, &buf); err != nil {
		t.Fatalf("failed to generate: %v", err)
	}

	output := buf.String()

	// Check type-level documentation
	if !strings.Contains(output, "User represents a user") {
		t.Errorf("output should contain type documentation\nGot:\n%s", output)
	}

	// Check field documentation
	if !strings.Contains(output, "ID is the unique identifier") {
		t.Errorf("output should contain field documentation\nGot:\n%s", output)
	}
}

// TestE2E_IntegrationWithExamples tests with the actual example files.
func TestE2E_IntegrationWithExamples(t *testing.T) {
	// Skip if example files don't exist
	inputPath := "examples/input.go"
	tsTemplatePath := "templates/typescript.tmpl"
	zodTemplatePath := "templates/zod.tmpl"

	if _, err := os.Stat(inputPath); os.IsNotExist(err) {
		t.Skip("examples/input.go not found")
	}

	cfg := config.New()
	p := parser.New()

	file, err := p.ParseFile(inputPath)
	if err != nil {
		t.Fatalf("failed to parse example file: %v", err)
	}

	// Verify we parsed expected types
	expectedTypes := []string{"User", "Role", "Timestamps", "Address", "OrderStatus", "Order", "OrderItem", "ProductCategory", "Product"}
	typeNames := make(map[string]bool)
	for _, typ := range file.Types {
		typeNames[typ.Name] = true
	}

	for _, expected := range expectedTypes {
		if !typeNames[expected] {
			t.Errorf("expected to parse type %s", expected)
		}
	}

	t.Run("TypeScript generation", func(t *testing.T) {
		if _, err := os.Stat(tsTemplatePath); os.IsNotExist(err) {
			t.Skip("typescript.tmpl not found")
		}

		gen := generator.New(cfg)
		if err := gen.LoadTemplate(tsTemplatePath); err != nil {
			t.Fatalf("failed to load TypeScript template: %v", err)
		}

		var buf bytes.Buffer
		if err := gen.Generate(file, &buf); err != nil {
			t.Fatalf("failed to generate TypeScript: %v", err)
		}

		output := buf.String()
		if len(output) == 0 {
			t.Error("generated empty TypeScript output")
		}

		// Basic sanity checks
		if !strings.Contains(output, "export interface User") {
			t.Error("TypeScript output should contain User interface")
		}
		if !strings.Contains(output, "export type Role") {
			t.Error("TypeScript output should contain Role type")
		}
	})

	t.Run("Zod generation", func(t *testing.T) {
		if _, err := os.Stat(zodTemplatePath); os.IsNotExist(err) {
			t.Skip("zod.tmpl not found")
		}

		gen := generator.New(cfg)
		if err := gen.LoadTemplate(zodTemplatePath); err != nil {
			t.Fatalf("failed to load Zod template: %v", err)
		}

		var buf bytes.Buffer
		if err := gen.Generate(file, &buf); err != nil {
			t.Fatalf("failed to generate Zod: %v", err)
		}

		output := buf.String()
		if len(output) == 0 {
			t.Error("generated empty Zod output")
		}

		// Basic sanity checks
		if !strings.Contains(output, "import { z } from 'zod'") {
			t.Error("Zod output should contain import")
		}
		if !strings.Contains(output, "UserSchema") {
			t.Error("Zod output should contain UserSchema")
		}
	})

	t.Run("Valibot generation", func(t *testing.T) {
		valibotTemplatePath := "templates/valibot.tmpl"
		if _, err := os.Stat(valibotTemplatePath); os.IsNotExist(err) {
			t.Skip("valibot.tmpl not found")
		}

		gen := generator.New(cfg)
		if err := gen.LoadTemplate(valibotTemplatePath); err != nil {
			t.Fatalf("failed to load Valibot template: %v", err)
		}

		var buf bytes.Buffer
		if err := gen.Generate(file, &buf); err != nil {
			t.Fatalf("failed to generate Valibot: %v", err)
		}

		output := buf.String()
		if len(output) == 0 {
			t.Error("generated empty Valibot output")
		}

		// Basic sanity checks
		if !strings.Contains(output, "import * as v from 'valibot'") {
			t.Error("Valibot output should contain import")
		}
		if !strings.Contains(output, "UserSchema") {
			t.Error("Valibot output should contain UserSchema")
		}
		if !strings.Contains(output, "v.InferOutput") {
			t.Error("Valibot output should contain type inference")
		}
	})

	t.Run("Valibot form generation", func(t *testing.T) {
		valibotFormTemplatePath := "templates/valibot-form.tmpl"
		if _, err := os.Stat(valibotFormTemplatePath); os.IsNotExist(err) {
			t.Skip("valibot-form.tmpl not found")
		}

		gen := generator.New(cfg)
		if err := gen.LoadTemplate(valibotFormTemplatePath); err != nil {
			t.Fatalf("failed to load Valibot form template: %v", err)
		}

		var buf bytes.Buffer
		if err := gen.Generate(file, &buf); err != nil {
			t.Fatalf("failed to generate Valibot form: %v", err)
		}

		output := buf.String()
		if len(output) == 0 {
			t.Error("generated empty Valibot form output")
		}

		// Basic sanity checks
		if !strings.Contains(output, "import * as v from 'valibot'") {
			t.Error("Valibot form output should contain import")
		}
		if !strings.Contains(output, "UserSchema") {
			t.Error("Valibot form output should contain UserSchema")
		}
		if !strings.Contains(output, "v.optional") {
			t.Error("Valibot form output should use v.optional for form fields")
		}
	})
}
